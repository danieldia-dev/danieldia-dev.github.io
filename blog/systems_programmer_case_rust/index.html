<!doctype html><html lang=en-us class=scroll-smooth><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>A Systems Programmer's Case for Rust - Daniel Dia's Personal Website</title>
  
    
    
      
        
          <link rel="stylesheet" href="/css/main.6076eb3c16fe404f3c13e0a0d436572689a9174f5a22bd73581c8540b83e3215.css" integrity="sha256-YHbrPBb&#43;QE88E&#43;Cg1DZXJompF09aIr1zWByFQLg&#43;MhU=" crossorigin="anonymous">
        
      
    
  

<link rel=icon type=image/png href=/D2.png><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;700&display=swap" rel=stylesheet></head><body class="flex flex-col min-h-screen font-sans"><header class=site-header><meta property="og:title" content="Daniel Dia"><meta property="og:description" content="Computer & Communications Engineering & Mathematics student @AUB | Economics Enthusiast"><meta property="og:type" content="website"><meta property="og:url" content="https://kibalchish47.github.io/"><meta property="og:image" content="https://kibalchish47.github.io/social-preview.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Daniel Dia"><meta name=twitter:description content="Computer & Communications Engineering & Mathematics student @AUB | Economics Enthusiast"><meta name=twitter:image content="https://kibalchish47.github.io/social-preview.png"><div class="container mx-auto px-6 py-4 flex flex-col md:flex-row justify-between items-center"><a href=/ class="text-3xl font-bold mb-4 md:mb-0 text-custom-gray-800">Daniel Dia</a><nav class="flex flex-wrap justify-center md:space-x-1"><a href=/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Homepage</a>
<a href=/about/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">About</a>
<a href=/portfolio/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Portfolio</a>
<a href=/blog/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Blog</a>
<a href=/publications/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Publications</a>
<a href=/contact/ class="nav-link px-5 py-2 text-custom-gray-700 hover:text-custom-red-500 hover:bg-custom-red-100 rounded-md transition-colors duration-300">Contact</a></nav></div></header><main class="container mx-auto px-6 py-8 flex-grow"><article class="p-6 bg-white rounded-xl shadow-lg"><header class="mb-8 text-center"><h1 class="text-4xl font-bold text-custom-red-500">A Systems Programmer's Case for Rust</h1><p class="text-sm text-custom-gray-600 mt-2">September 27, 2025</p><div class=mt-2><span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Rust</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Systems Programming</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">C++</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Memory Safety</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Concurrency</span>
<span class="inline-block bg-custom-red-100 text-custom-red-500 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded">Software Engineering</span></div></header><hr class=custom-divider><div class="prose prose-custom-red lg:prose-xl max-w-none prose-sm md:prose-base"><blockquote><p>For me, the main thing is that it&rsquo;s a modern language. It&rsquo;s a language that was designed to fix all the warts that we&rsquo;ve had in all the other languages.</p></blockquote><p>— <strong>Andreas Jung, Rust Core Team Member.</strong></p><h2 id=introduction>Introduction</h2><p>For decades, the world of systems programming has been dominated by a single titan: C++. Its promise of &ldquo;zero-cost abstractions&rdquo; and direct hardware access has made it the default choice for performance-critical domains, from game engines and operating systems to high-frequency trading. Yet, this power comes at a price—a notoriously steep learning curve and a constant, looming threat of memory-related bugs and security vulnerabilities that have plagued the industry for years.</p><p>This has led to a fundamental trade-off: choose a language like C++ for raw performance at the cost of safety and complexity, or opt for a garbage-collected language like Java or Go for safety and simplicity at the cost of performance and predictability.</p><p>Rust, a language that began as a personal project by Graydon Hoare at Mozilla Research in 2006, fundamentally challenges this trade-off. It is designed to provide the low-level control and bare-metal performance of C++ while guaranteeing memory safety and data-race-free concurrency at compile time. This is not an incremental improvement; it is a paradigm shift in how we can approach building reliable, high-performance software. This post will provide a technical overview of Rust&rsquo;s core value propositions, compare its design decisions to those of other major languages, and explore why it&rsquo;s rapidly moving from a niche interest to a strategic choice for some of the world&rsquo;s largest technology companies.</p><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#introduction>Introduction</a></li><li><a href=#table-of-contents>Table of Contents</a></li><li><a href=#data-behavior-and-types-a-new-way-of-thinking>Data, Behavior, and Types: A New Way of Thinking</a><ul><li><a href=#what-is-a-type-from-data-to-information>What is a &ldquo;Type&rdquo;? From Data to Information</a></li><li><a href=#data-is-just-data-structs-and-enums>Data is Just Data: <code>structs</code> and <code>enums</code></a></li><li><a href=#making-impossible-states-impossible-match-vs-switch>Making Impossible States Impossible: <code>match</code> vs. <code>switch</code></a><ul><li><a href=#rusts-compile-time-guarantee>Rust&rsquo;s Compile-Time Guarantee:</a></li><li><a href=#gos-runtime-hopefulness>Go&rsquo;s Runtime Hopefulness:</a></li><li><a href=#cs-verbose-visitor>C++&rsquo;s Verbose Visitor:</a></li></ul></li><li><a href=#behavior-as-traits-composition-over-inheritance>Behavior as Traits: Composition Over Inheritance</a></li></ul></li><li><a href=#a-critique-of-object-oriented-programming-and-cs-design-philosophy>A Critique of Object-Oriented Programming and C++&rsquo;s Design Philosophy</a><ul><li><a href=#the-failures-of-the-oop-dream>The Failures of the OOP Dream</a></li><li><a href=#c-the-swiss-army-knife-with-200-dull-blades>C++: The Swiss Army Knife with 200 Dull Blades</a></li><li><a href=#the-functional-programming-detour-purity-at-a-price>The Functional Programming Detour: Purity at a Price</a></li></ul></li><li><a href=#the-ownership-model-a-paradigm-shift-in-memory-safety>The Ownership Model: A Paradigm Shift in Memory Safety</a><ul><li><a href=#ownership-deterministic-resource-management>Ownership: Deterministic Resource Management</a><ul><li><a href=#c-example-raii-with-stdunique_ptr>C++ Example (RAII with <code>std::unique_ptr</code>):</a></li><li><a href=#rust-equivalent-ownership-move>Rust Equivalent (Ownership Move):</a></li></ul></li><li><a href=#borrowing-enforcing-data-discipline>Borrowing: Enforcing Data Discipline</a><ul><li><a href=#c-use-after-free-via-iterator-invalidation>C++ Use-After-Free via Iterator Invalidation:</a></li><li><a href=#rusts-compile-time-prevention>Rust&rsquo;s Compile-Time Prevention:</a></li></ul></li><li><a href=#lifetimes-eliminating-dangling-pointers>Lifetimes: Eliminating Dangling Pointers</a><ul><li><a href=#c-dangling-pointer>C++ Dangling Pointer:</a></li><li><a href=#rusts-compile-time-prevention-and-solution>Rust&rsquo;s Compile-Time Prevention (and Solution):</a></li></ul></li></ul></li><li><a href=#a-modern-development-experience-abstractions-and-tooling>A Modern Development Experience: Abstractions and Tooling</a><ul><li><a href=#world-class-tooling-cargo-and-the-ecosystem>World-Class Tooling: Cargo and the Ecosystem</a></li><li><a href=#a-precise-gui-example-oop-vs-data-oriented>A Precise GUI Example: OOP vs. Data-Oriented</a><ul><li><a href=#typical-oop-approach-eg-in-javac>Typical OOP Approach (e.g., in Java/C#):</a></li><li><a href=#rusts-trait-based-approach>Rust&rsquo;s Trait-Based Approach:</a></li></ul></li><li><a href=#robust-error-handling-result-vs-exceptions-and-nil>Robust Error Handling: Result vs. Exceptions and <code>nil</code></a><ul><li><a href=#explicit-handling-with-match>Explicit Handling with match</a></li><li><a href=#gos-if-err--nil-boilerplate>Go&rsquo;s <code>if err != nil</code> Boilerplate:</a></li><li><a href=#cjavas-invisible-control-flow>C++/Java&rsquo;s Invisible Control Flow:</a></li><li><a href=#rusts--operator>Rust&rsquo;s <code>?</code> Operator:</a></li></ul></li></ul></li><li><a href=#industry-adoption-from-theory-to-production-code>Industry Adoption: From Theory to Production Code</a></li><li><a href=#who-is-rust-for-identifying-the-ideal-use-cases>Who is Rust For? Identifying the Ideal Use Cases</a></li><li><a href=#conclusion-a-new-baseline-for-systems-programming>Conclusion: A New Baseline for Systems Programming</a></li></ul><h2 id=data-behavior-and-types-a-new-way-of-thinking>Data, Behavior, and Types: A New Way of Thinking</h2><p>Many mainstream languages like Java and C++ are built around classical <strong>Object-Oriented Programming (OOP),</strong> where data and behavior are tightly coupled within objects that inherit from one another.</p><p>Rust takes a different approach, drawing inspiration from <strong>functional programming</strong> and type theory to favor a data-oriented design <strong>based on composition over inheritance</strong>.</p><h3 id=what-is-a-type-from-data-to-information>What is a &ldquo;Type&rdquo;? From Data to Information</h3><p>In systems programming, we often think of a <strong>type</strong> as just a description of data in memory (e.g., <code>int</code> is 4 bytes). In functional programming and type theory, a type is a much richer concept: it&rsquo;s a formal way of <strong>classifying values and expressing constraints</strong> on them.</p><p><strong>A type system is a tool for reasoning about your program&rsquo;s correctness before it runs</strong>.</p><p><strong>Haskell</strong> represents the pinnacle of this pure, academic approach, with an extremely powerful type system that can prove complex properties about a program at compile time. However, this often comes at the cost of being disconnected from the low-level realities of hardware. <strong>C++</strong>, on the other hand, is all about the hardware, but its type system is comparatively weak at enforcing high-level invariants.</p><p><strong>Rust</strong> strikes a pragmatic balance. It has a <strong>rich type system</strong> inspired by Haskell (e.g., algebraic data types, traits) but is fundamentally <strong>designed for systems programming</strong>. It uses types not just to describe memory layouts, but to enforce high-level rules about resource management, concurrency, and program state.</p><h3 id=data-is-just-data-structs-and-enums>Data is Just Data: <code>structs</code> and <code>enums</code></h3><p>In Rust, the primary tools for modeling your domain are structs and enums. Important note: they are used to hold data, and <strong>nothing</strong> else.</p><ul><li><p><strong>Structs:</strong> Simple aggregations of data. They are like <code>C</code> structs or <code>C++</code> structs without methods defined inside them. They just hold data.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Player</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>health</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>level</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>Enums (Algebraic Data Types):</strong> Rust&rsquo;s enums are far more powerful than their <code>C/C++</code> counterparts. They are Algebraic Data Types (ADTs), meaning each variant can hold different data. This allows you to encode program state in the type system itself.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>WebEvent</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>PageLoad</span><span class=p>,</span><span class=w>                     </span><span class=c1>// Variant with no data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>KeyPress</span><span class=p>(</span><span class=kt>char</span><span class=p>),</span><span class=w>               </span><span class=c1>// Variant with a tuple
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>Click</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span>: <span class=kt>i64</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kt>i64</span> <span class=p>},</span><span class=w>     </span><span class=c1>// Variant with a struct
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><h3 id=making-impossible-states-impossible-match-vs-switch>Making Impossible States Impossible: <code>match</code> vs. <code>switch</code></h3><p>The <code>match</code> statement used with enums is exhaustive: the compiler will error if you forget to handle a variant. This is a significant safety improvement over the C++ <code>std::variant</code> or Go&rsquo;s <code>interface{}</code> with a type switch. Let&rsquo;s consider handling requests in a simple network server.</p><h4 id=rusts-compile-time-guarantee>Rust&rsquo;s Compile-Time Guarantee:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Request</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Get</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Post</span><span class=p>(</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Delete</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Let&#39;s add a new request type later: Put(String, String)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>handle_request</span><span class=p>(</span><span class=n>req</span>: <span class=nc>Request</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>req</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Request</span>::<span class=n>Get</span><span class=p>(</span><span class=n>path</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;GET </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>path</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Request</span>::<span class=n>Post</span><span class=p>(</span><span class=n>path</span><span class=p>,</span><span class=w> </span><span class=n>body</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;POST </span><span class=si>{}</span><span class=s>: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>path</span><span class=p>,</span><span class=w> </span><span class=n>body</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Whoops! We forgot to handle the Delete variant.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This code will simply not compile. The Rust compiler stops you with a clear error:
<code>error[E0004]: non-exhaustive patterns: Delete(_) not covered</code></p><p>This forces the developer to account for all possibilities, preventing entire classes of bugs. The correct, exhaustive version would handle all variants. This becomes invaluable when you refactor: if you add a new <code>Request::Put</code> variant to the enum, the compiler will instantly show you every single match statement in your codebase that needs to be updated.</p><p><a href=https://doc.rust-lang.org/error_codes/E0004.html>For more details, see the official Rust documentation for error[E0004].</a>.</p><h4 id=gos-runtime-hopefulness>Go&rsquo;s Runtime Hopefulness:</h4><p>Go uses <code>interface{}</code> and type switches to achieve similar polymorphism, but the check is at runtime, not compile time (like in Rust).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>GetRequest</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>Path</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>type</span><span class=w> </span><span class=nx>PostRequest</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>Path</span><span class=p>,</span><span class=w> </span><span class=nx>Body</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>type</span><span class=w> </span><span class=nx>DeleteRequest</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>Path</span><span class=w> </span><span class=kt>string</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// If we add a PutRequest struct later, the compiler won&#39;t warn us.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>func</span><span class=w> </span><span class=nf>handleRequest</span><span class=p>(</span><span class=nx>req</span><span class=w> </span><span class=kd>interface</span><span class=p>{})</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>switch</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>req</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>case</span><span class=w> </span><span class=nx>GetRequest</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;GET %s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>r</span><span class=p>.</span><span class=nx>Path</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>case</span><span class=w> </span><span class=nx>PostRequest</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;POST %s: %s\n&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>r</span><span class=p>.</span><span class=nx>Path</span><span class=p>,</span><span class=w> </span><span class=nx>r</span><span class=p>.</span><span class=nx>Body</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// We forgot to handle DeleteRequest.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>default</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// This default case might not be what we want.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// If we forget it, the program just does nothing for that case.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Unknown request type&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This code compiles perfectly. If it receives a <code>DeleteRequest</code>, it will either do nothing or hit a default case, hiding a bug that Rust would have caught.</p><h4 id=cs-verbose-visitor>C++&rsquo;s Verbose Visitor:</h4><p>C++ <code>std::variant</code> is a significant improvement over C-style <strong>unions</strong>, but ensuring exhaustiveness is less ergonomic than Rust&rsquo;s match. A common pattern is <code>std::visit</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;variant&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>GetRequest</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>PostRequest</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>,</span> <span class=n>body</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>DeleteRequest</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>path</span><span class=p>;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>Request</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>variant</span><span class=o>&lt;</span><span class=n>GetRequest</span><span class=p>,</span> <span class=n>PostRequest</span><span class=p>,</span> <span class=n>DeleteRequest</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>handle_request</span><span class=p>(</span><span class=k>const</span> <span class=n>Request</span><span class=o>&amp;</span> <span class=n>req</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>visit</span><span class=p>([](</span><span class=k>auto</span><span class=o>&amp;&amp;</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>T</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>decay_t</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=k>constexpr</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>GetRequest</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// handle Get
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=k>constexpr</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>is_same_v</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>PostRequest</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// handle Post
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// No compile error for forgetting DeleteRequest.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// Advanced template magic can be used to check for exhaustiveness,
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// but it&#39;s not a built-in guarantee of the language&#39;s control flow.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>},</span> <span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Like Go, the C++ version compiles without complaint, silently ignoring the unhandled <code>DeleteRequest</code>. While modern C++ provides tools to build compile-time checks for this, they are not a fundamental, out-of-the-box feature of the <code>switch</code> or <code>if-constexpr</code> constructs. Rust&rsquo;s match integrates this safety check directly and simply.</p><p>See <a href=https://doc.rust-lang.org/book/ch05-00-structs.html>Chapter 5 (&ldquo;Using Structs to Structure Related Data&rdquo;)</a> and <a href=https://doc.rust-lang.org/book/ch06-00-enums.html>Chapter 6 (&ldquo;Enums and Pattern Matching&rdquo;)</a> of the Rust Book for more, as well as <a href=https://doc.rust-lang.org/rust-by-example/custom_types.html>Section 3 (&ldquo;Custom Types&rdquo;) of Rust by Example (RBE)</a>.</p><h3 id=behavior-as-traits-composition-over-inheritance>Behavior as Traits: Composition Over Inheritance</h3><blockquote><p>The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.</p></blockquote><p>— <strong>Joe Armstrong, creator of Erlang.</strong></p><p>In other words, in an object-oriented language such as Java or C++, if a hypothetical <code>Gorilla</code> class inherits from a <code>JungleAnimal</code> class, it drags all that parent complexity with it. If all you need is the <code>eat_banana()</code> behavior, you&rsquo;re forced to accept the entire jungle. This often leads to the &ldquo;<em>brittle base class</em>&rdquo; problem, where a change in a parent class can unexpectedly break child classes in subtle ways.</p><p>Instead of methods living inside a class, Rust separates them. You define <strong>behavior</strong> in <code>impl</code> blocks, often by implementing traits. A <code>trait</code> is a <strong>collection of method signatures</strong> that defines a <strong>shared capability or concept</strong> (e.g., <code>Draw</code>, <code>Clone</code>, <code>Debug</code>). It is an interface that a type can choose to implement.</p><p>This is fundamentally about <strong>composition</strong>. You start with simple data structures (<code>structs</code> and <code>enums</code>) and then compose behaviors onto them by implementing <code>traits</code>. This is far more flexible than inheritance.</p><p>For example, in embedded programming, you could model a <code>GPIO</code> pin like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// The TYPE: simple data describing a pin
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>GpioPin</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>port</span>: <span class=kt>char</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>pin_number</span>: <span class=kt>u8</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// The BEHAVIORS, defined as separate traits
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>GpioWrite</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set_high</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set_low</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>GpioRead</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>is_high</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// The IMPLEMENTATION: applying a behavior to a type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=w> </span><span class=n>GpioWrite</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>GpioPin</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set_high</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* hardware-specific code to set pin high */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set_low</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* hardware-specific code to set pin low */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Here, a <code>GpioPin</code> is just data, it does include any &ldquo;behavioral&rdquo; code. We grant it the ability to be written to by implementing the <code>GpioWrite</code> trait for it. If it were also a readable pin, we could simply add another <code>impl GpioRead for GpioPin</code>. This avoids the rigid hierarchies of OOP, where you might be forced to create awkward classes like <code>WriteOnlyPin</code> or <code>ReadWritePin</code>.</p><p><a href=https://doc.rust-lang.org/book/ch10-00-generics.html>See Chapter 10 (&ldquo;Generic Types, Traits, and Lifetimes&rdquo;) of The Rust Book for more on this</a> (specifically <a href=https://doc.rust-lang.org/book/ch10-02-traits.html>Section 10.2.</a>), as well as <a href=https://doc.rust-lang.org/rust-by-example/trait.html>Section 16 (&ldquo;Traits&rdquo;) of Rust by Example (RBE)</a>.</p><h2 id=a-critique-of-object-oriented-programming-and-cs-design-philosophy>A Critique of Object-Oriented Programming and C++&rsquo;s Design Philosophy</h2><p>The trait-based approach stands in <strong>stark contrast</strong> to the design of languages like C++ and Java, and indeed, to the <strong>entire OOP paradigm</strong> as it is commonly practiced.</p><h3 id=the-failures-of-the-oop-dream>The Failures of the OOP Dream</h3><p>The <strong>promise</strong> of OOP was <strong>reusable</strong>, <strong>modular code through inheritance</strong>. Born from innovative ideas in languages like Simula and Smalltalk for modeling complex systems, it was popularized by C++ and Java in the 80s and 90s as the definitive solution for large-scale software engineering. The vision was an industrial one: build software from interchangeable, component-like objects. The <strong>reality</strong>, however, has often been <strong>brittle</strong>, <strong>complex</strong>, and <strong>deeply coupled systems</strong>.</p><blockquote><p>The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.</p></blockquote><p>— <strong>Joe Armstrong, creator of Erlang.</strong></p><p>Coming back to this quote, it perfectly captures the problem of such deep, rigid inheritance hierarchies. If a <code>Gorilla</code> class inherits from a <code>JungleAnimal</code> class, which inherits from <code>Mammal</code>, it drags all that parent complexity with it. This creates several problems:</p><ul><li><p><strong>The Brittle Base Class Problem:</strong> A seemingly innocuous change in a parent class can unexpectedly break child classes in subtle ways. The tight coupling between parent and child makes the system fragile.</p></li><li><p><strong>Inflexible Hierarchies:</strong> Real-world concepts don&rsquo;t always fit into neat tree structures. What if you want an object that is both a <code>Vehicle</code> and a <code>Building</code> (like a mobile home)? OOP forces you into convoluted patterns like multiple inheritance (C++) or interfaces with default methods (Java), which are often (to put it lightly) <em>clumsy</em> workarounds.</p></li><li><p><strong>Encapsulation Breakdown:</strong> True encapsulation is about hiding implementation details. But in many OOP designs, inheritance requires the child class to know intimate details about the parent&rsquo;s implementation, violating this core principle.</p></li></ul><p>Rust&rsquo;s trait system avoids this entirely. You don&rsquo;t inherit a &ldquo;jungle&rdquo;; you simply implement the <code>EatsBananas</code> <strong>trait</strong> for your <code>Gorilla</code> <strong>struct</strong>. The data and behavior are decoupled, allowing for maximum flexibility and true modularity.</p><h3 id=c-the-swiss-army-knife-with-200-dull-blades>C++: The Swiss Army Knife with 200 Dull Blades</h3><p>The issues with OOP are compounded in C++ by its design philosophy, which can be summarized as &ldquo;<strong>include everything and let the user figure it out.</strong>&rdquo; This has led to a language of immense, arguably unnecessary, complexity. Unix pioneer Ken Thompson, co-creator of C, had a particularly sharp critique:</p><blockquote><p>It certainly has its good points. But by and large I think it&rsquo;s a bad language. It does a lot of things half well and it&rsquo;s just a garbage heap of ideas that are mutually exclusive&mldr; It&rsquo;s way too big, way too complex. And it&rsquo;s obviously built by a committee. Stroustrup campaigned for years and years and years&mldr; to get it adopted and used. And he sort of ran all the standards committees with a whip and a chair. And he said &ldquo;no&rdquo; to no one. He put every feature in that language that ever existed. It wasn&rsquo;t cleanly designed—it was just the union of everything that came along. And I think it suffered drastically from that.</p></blockquote><p>— <strong>Ken Thompson, Unix pioneer and co-creator of C.</strong></p><p>This describes a language that, in trying to please everyone, created a minefield. C++ has multiple ways to do almost everything (e.g., at least five forms of initialization, <code>unique_ptr</code> vs. <code>shared_ptr</code> vs. raw pointers), and the &ldquo;correct&rdquo; choice is often subtle and context-dependent. This leads to the &ldquo;subset&rdquo; problem: every organization uses a different, mutually incompatible subset of C++, making code portability a nightmare. <strong>C++ isn&rsquo;t a coherent language; it&rsquo;s a collection of features bolted together over decades</strong>.</p><h3 id=the-functional-programming-detour-purity-at-a-price>The Functional Programming Detour: Purity at a Price</h3><p>As the limitations of mainstream OOP became more apparent, another school of thought, rooted in academia and mathematics, offered a different path: <strong>functional programming (FP)</strong>. Languages like Lisp, Scheme, and later OCaml and Haskell, proposed a radical alternative. Instead of bundling mutable state and behavior into objects, FP emphasizes:</p><ul><li><p><strong>Immutability:</strong> Data structures are unchangeable by default. Instead of modifying data, you create new data with the desired changes.</p></li><li><p><strong>Pure Functions:</strong> Functions are treated as mathematical mappings from inputs to outputs. A pure function will always produce the same output for the same input and has no observable side effects (like modifying global state or performing <code>I/O</code>).</p></li><li><p><strong>First-Class Functions:</strong> Functions are values, just like numbers or strings. They can be passed as arguments, returned from other functions, and stored in data structures.</p></li></ul><p>This approach <strong>eliminates entire classes of bugs related to shared mutable state</strong>, which are a primary cause of complexity in OOP and concurrent systems. Haskell, in particular, represents the zenith of this philosophy, with a powerful static type system that enforces purity. To handle necessary side effects like I/O or state mutation, it uses advanced <strong>type-system constructs</strong> like monads. In a way, monads allow programmers to explicitly sequence operations and manage state in a controlled, contained manner, <strong>emulating some of the encapsulation benefits of OOP</strong> without its pitfalls of implicit state and inheritance.</p><p>However, this purity comes with its own set of trade-offs, especially for systems programming. The heavy reliance on immutability can lead to <strong>performance challenges</strong> if not managed carefully, and the high level of abstraction can obscure the underlying hardware realities of memory layout and control flow. For many systems developers, the purely functional world felt powerful but impractical for writing device drivers or game engines. This created a chasm: on one side, the <em>unsafe, complex, but hardware-centric world</em> of <strong>C++</strong>; on the other, <em>the safe, elegant, but abstract world</em> of <strong>Haskell</strong>. It is precisely this chasm that Rust was designed to bridge. Rust was designed with a clear, opinionated vision from the start.</p><p>For a deeper dive into Rust&rsquo;s functional programming features, <a href=https://doc.rust-lang.org/book/ch13-00-functional-features.html>see Chapter 13 (&ldquo;Functional Language Features: Iterators and Closures&rdquo;) of The Rust Book</a>.</p><h2 id=the-ownership-model-a-paradigm-shift-in-memory-safety>The Ownership Model: A Paradigm Shift in Memory Safety</h2><p>The heart of Rust&rsquo;s value proposition is its <strong>ownership model</strong>, a novel approach to memory management that operates entirely at compile time. To appreciate its significance, one must <strong>contrast</strong> it with the two dominant paradigms: <strong>manual memory management</strong> (C/C++) and <strong>automatic garbage collection</strong> (Java/Go).</p><h3 id=ownership-deterministic-resource-management>Ownership: Deterministic Resource Management</h3><p>In Rust, every value has a single &ldquo;owner.&rdquo; When the owner goes out of scope, the value is &ldquo;dropped,&rdquo; and its resources (memory, file handles, network sockets) are freed. This deterministic, scope-based resource management is known as <code>RAII</code> (<strong>Resource Acquisition Is Initialization</strong>), a pattern familiar to C++ developers.</p><p>However, Rust makes two crucial changes:</p><ul><li>First, it&rsquo;s <strong>universal and non-negotiable</strong>.</li><li>Second, when a value is <strong>assigned to another variable</strong> or <strong>passed to a function</strong>, its <strong>ownership is moved</strong>. The original variable is now considered uninitialized and cannot be used, a rule enforced at compile time. This elegantly prevents &ldquo;double frees&rdquo; and makes the flow of ownership explicit.</li></ul><p><a href=https://doc.rust-lang.org/rust-by-example/scope/raii.html>See Section 15.1. (&ldquo;RAII&rdquo;) of Rust by Example (RBE) for more.</a></p><h4 id=c-example-raii-with-stdunique_ptr>C++ Example (RAII with <code>std::unique_ptr</code>):</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Processing: &#34;</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// `s` is destroyed here, memory is freed.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>my_string</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>process_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>my_string</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// std::cout &lt;&lt; *my_string; // Compile Error! my_string was moved.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=rust-equivalent-ownership-move>Rust Equivalent (Ownership Move):</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>process_string</span><span class=p>(</span><span class=n>s</span>: <span class=nb>String</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Processing: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=c1>// `s` goes out of scope and is dropped here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>my_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>process_string</span><span class=p>(</span><span class=n>my_string</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// println!(&#34;{}&#34;, my_string); // Compile Error! Value borrowed after move.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>While both prevent use-after-move, Rust&rsquo;s ownership is fundamental. This contrasts with garbage-collected languages like Go, where the programmer has no control over when memory is freed, leading to potential non-determinism in resource cleanup and performance.</p><p>For a full breakdown, <a href=https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html>see Chapter 4 (&ldquo;Understanding Ownership&rdquo;) of The Rust Programming Language Book</a>, as well as <a href=https://doc.rust-lang.org/rust-by-example/scope/move.html>Section 15.2. (&ldquo;Ownership and moves&rdquo;) of Rust by Example (RBE)</a>.</p><h3 id=borrowing-enforcing-data-discipline>Borrowing: Enforcing Data Discipline</h3><p>Moving ownership constantly would be impractical. Rust&rsquo;s solution is borrowing, which allows parts of the code to <strong>access data via references without taking ownership</strong>. The borrow checker, Rust&rsquo;s most famous feature, enforces a <strong>critical set of rules</strong> at compile time:</p><ul><li><p>You can have <em><strong>ANY number</strong></em> of <strong>immutable</strong> references (<code>&amp;T</code>) simultaneously.</p></li><li><p>You can have <em><strong>ONLY ONE</strong></em> <strong>mutable</strong> reference (<code>&amp;mut T</code>).</p></li><li><p>A mutable reference cannot exist at the same time as any immutable references.</p></li></ul><p>This &ldquo;<em>aliasing XOR mutability</em>&rdquo; rule eliminates entire categories of bugs, from simple data corruption to complex data races in concurrent code.</p><h4 id=c-use-after-free-via-iterator-invalidation>C++ Use-After-Free via Iterator Invalidation:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>&amp;</span> <span class=n>first</span> <span class=o>=</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span> <span class=c1>// Create a reference to the first element.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// This push_back might cause the vector to reallocate its memory,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// invalidating all existing references.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// `first` is now a dangling reference. Accessing it is undefined behavior.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;First element is: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=c1>// Potential crash!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>This code compiles but can crash or produce garbage data at runtime. The responsibility to avoid this lies entirely with the programmer.</p><h4 id=rusts-compile-time-prevention>Rust&rsquo;s Compile-Time Prevention:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w> </span><span class=c1>// Create an immutable borrow.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// This line will NOT compile.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>v</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span><span class=w> </span><span class=c1>// ERROR: cannot borrow `v` as mutable because it is also borrowed as immutable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The compiler stops us long before this line is ever reached.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// println!(&#34;First element is: {}&#34;, first);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The borrow checker sees that <code>v.push()</code> requires a mutable borrow of <code>v</code> while first holds an immutable borrow. It rejects the program, <strong>preventing the possibility of the bug</strong>.</p><p>See <a href=https://doc.rust-lang.org/rust-by-example/scope/borrow.html>Section 15.3. (&ldquo;Borrowing&rdquo;) of Rust by Example (RBE)</a> for more on this.</p><h3 id=lifetimes-eliminating-dangling-pointers>Lifetimes: Eliminating Dangling Pointers</h3><p>The final piece is <strong>ensuring references never outlive the data they point to</strong>. The compiler achieves this through lifetime analysis. In most cases, lifetimes are inferred automatically. When ambiguity arises, the programmer provides <strong>explicit lifetime annotations</strong>.</p><h4 id=c-dangling-pointer>C++ Dangling Pointer:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>get_longest</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s1</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>s1</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&gt;</span> <span class=n>s2</span><span class=p>.</span><span class=n>length</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>s1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>temp</span> <span class=o>=</span> <span class=s>&#34;longer&#34;</span><span class=p>;</span> <span class=c1>// A local variable
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>temp</span><span class=p>;</span> <span class=c1>// Returns a reference to `temp`, which is destroyed here!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above code is a <strong>ticking time bomb</strong> (waiting to ruin your weekend) that compiles but returns a reference to memory that has been deallocated.</p><h4 id=rusts-compile-time-prevention-and-solution>Rust&rsquo;s Compile-Time Prevention (and Solution):</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// This function signature tells the compiler that the returned reference
</span></span></span><span class=line><span class=cl><span class=c1>// must live at least as long as the SHORTEST of the two input references.
</span></span></span><span class=line><span class=cl><span class=c1>// The `&#39;a` is a lifetime parameter.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>get_longest</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s1</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>s2</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>s1</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>s2</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>s1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>s2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>string1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;long string is long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>string2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;xyz&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// This works because both s1 and s2 are valid here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_longest</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string1</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>string2</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Inside scope, longest is: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w> </span><span class=c1>// This is fine.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// println!(&#34;The longest string is {}&#34;, result); // COMPILE ERROR! `string2` does not live long enough.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The Rust compiler understands that <code>string2</code> is destroyed at the end of the inner scope. It sees that result could potentially be a reference to <code>string2</code>, and therefore flags the final <code>println!</code> as an error because result would be a dangling pointer. This entire class of bugs is eliminated at compile time. How cute is that?</p><p>For a deep dive, <a href=https://doc.rust-lang.org/book/ch10-00-generics.html>see Chapter 10 (&ldquo;Generic Types, Traits, and Lifetimes&rdquo;) of The Rust Book</a>, as well as <a href=https://doc.rust-lang.org/rust-by-example/scope/lifetime.html>Section 15.4. (&ldquo;Lifetimes&rdquo;) of Rust by Example (RBE)</a>.</p><h2 id=a-modern-development-experience-abstractions-and-tooling>A Modern Development Experience: Abstractions and Tooling</h2><p>While memory safety is the headline feature, it&rsquo;s the modern developer experience that often wins &ldquo;converts&rdquo;.</p><h3 id=world-class-tooling-cargo-and-the-ecosystem>World-Class Tooling: Cargo and the Ecosystem</h3><p>Rust comes with <code>Cargo</code>, an integrated package manager and build system that is nothing short of revolutionary for developers (read &ldquo;blasphemers&rdquo;) coming from C++. It handles:</p><ul><li><p><strong>Dependency Management:</strong> The <code>Cargo.toml</code> manifest file is a simple, declarative way to specify dependencies from the central crates.io repository. This stands in stark contrast to the fragmented C++ ecosystem of <code>Conan</code>, <code>vcpkg</code>, and manual library management.</p></li><li><p><strong>Reproducible Builds:</strong> Cargo automatically generates a <code>Cargo.lock</code> file, ensuring that every developer on a project, and the CI server, gets the exact same version of every dependency, eliminating &ldquo;works on my machine&rdquo; issues.</p></li><li><p><strong>Integrated Toolchain:</strong> A single cargo command can build your project (<code>cargo build</code>), run tests (<code>cargo test</code>), generate test coverage (<code>cargo tarpaulin</code>), run benchmarks (<code>cargo bench</code>), generate documentation (<code>cargo doc</code>), format code (<code>cargo fmt</code>), and run a powerful static analyzer (<code>cargo clippy</code>). This consistency is a massive productivity boost compared to orchestrating <code>Makefiles</code>, <code>CMake</code>, <code>Doxygen</code>, and <code>Clang-Tidy</code>.</p></li></ul><p>See <a href=https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html>Chapter 7 (&ldquo;Managing Growing Projects with Packages, Crates, and Modules&rdquo;)</a> and <a href=https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html>Chapter 14 (&ldquo;More About Cargo and Crates.io&rdquo;)</a> of The Rust Book, as well as <a href=https://doc.rust-lang.org/rust-by-example/cargo.html>Section 12 of Rust by Example (RBE)</a> for more.</p><h3 id=a-precise-gui-example-oop-vs-data-oriented>A Precise GUI Example: OOP vs. Data-Oriented</h3><p>Let&rsquo;s make the GUI example more concrete to see the practical difference.</p><h4 id=typical-oop-approach-eg-in-javac>Typical OOP Approach (e.g., in Java/C#):</h4><p>Imagine a GUI library where everything must inherit from a <code>Widget</code> base class.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// A rigid hierarchy. What if we want a non-drawable, clickable region?
</span></span></span><span class=line><span class=cl><span class=c1>// You&#39;re forced to create an &#34;InvisibleWidget&#34; class.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span> <span class=n>abstract</span> <span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>protected</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>abstract</span> <span class=kt>void</span> <span class=nf>draw</span><span class=p>(</span><span class=n>Screen</span> <span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Maybe event handling is here too? Tightly coupled.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>public</span> <span class=n>boolean</span> <span class=nf>onEvent</span><span class=p>(</span><span class=n>Event</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Button</span> <span class=n>extends</span> <span class=n>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=n>String</span> <span class=n>label</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=n>Override</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>(</span><span class=n>Screen</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Draw button with label */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=n>Override</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>boolean</span> <span class=n>onEvent</span><span class=p>(</span><span class=n>Event</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>e</span> <span class=n>instanceof</span> <span class=n>ClickEvent</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Handle click */</span> <span class=k>return</span> <span class=nb>true</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>Image</span> <span class=n>extends</span> <span class=n>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=n>byte</span><span class=p>[]</span> <span class=n>imageData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=n>Override</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>(</span><span class=n>Screen</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* Draw image */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// An image isn&#39;t clickable, but it inherits the onEvent method anyway.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=rusts-trait-based-approach>Rust&rsquo;s Trait-Based Approach:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 1. Define distinct behaviors as traits.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Draw</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>screen</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Screen</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>EventHandler</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>on_event</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>event</span>: <span class=nc>Event</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 2. Define simple, independent data structures.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Button</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>label</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>clicked</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Image</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>data</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 3. Compose behaviors onto the data structures as needed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=w> </span><span class=n>Draw</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Button</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>screen</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Screen</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* Draw the button */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>EventHandler</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Button</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>on_event</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>event</span>: <span class=nc>Event</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>Event</span>::<span class=n>Click</span><span class=w> </span><span class=p>{</span><span class=o>..</span><span class=p>}</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>event</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>clicked</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Draw</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Image</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>screen</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Screen</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* Draw the image */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Note: Image does NOT implement EventHandler. It doesn&#39;t have that capability.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 4. Use traits to write generic code.
</span></span></span><span class=line><span class=cl><span class=c1>// This function can operate on any collection of drawable items.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>draw_all_widgets</span><span class=p>(</span><span class=n>widgets</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=o>&amp;</span><span class=k>dyn</span><span class=w> </span><span class=n>Draw</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>widget</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>widgets</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>widget</span><span class=p>.</span><span class=n>draw</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>Screen</span>::<span class=n>new</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This is far more flexible. The <strong>data</strong> (<code>Button</code>, <code>Image</code>) is <strong>decoupled</strong> from the <strong>behavior</strong> (<code>Draw</code>, <code>EventHandler</code>). An <code>Image</code> doesn&rsquo;t carry the dead weight of an event-handling method it will never use. If we need a new kind of interactive element, we just implement the <code>EventHandler</code> trait for it, without needing to fit it into a rigid <code>Widget</code> hierarchy.</p><p>More on Rust&rsquo;s &ldquo;Object-Oriented Programming (OOP)&rdquo; features <a href=https://doc.rust-lang.org/book/ch18-00-oop.html>in Chapter 18 (&ldquo;Object-Oriented Programming Features of Rust&rdquo;) of The Rust Book</a>.</p><h3 id=robust-error-handling-result-vs-exceptions-and-nil>Robust Error Handling: Result vs. Exceptions and <code>nil</code></h3><p>Rust eschews traditional exceptions, which can create invisible control flow paths and make it difficult to reason about a program&rsquo;s behavior. Instead, recoverable errors are handled explicitly through the <code>Result&lt;T, E></code> enum. A function that can fail has this possibility encoded directly in its return type. It will return either <code>Ok(T)</code> with the success value of type <code>T</code>, or <code>Err(E)</code> with an error value of type <code>E</code>. Most importantly, the compiler forces you to handle the <code>Err</code> case, making it impossible to accidentally ignore a potential failure.</p><h4 id=explicit-handling-with-match>Explicit Handling with match</h4><p>Let&rsquo;s look at a function for safe division. Instead of crashing on division by zero, it returns a <code>Result</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>safe_divide</span><span class=p>(</span><span class=n>numerator</span>: <span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=n>denominator</span>: <span class=kt>f64</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>denominator</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mf>0.0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// On failure, return an Err variant with an error message.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Cannot divide by zero&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// On success, return an Ok variant with the result.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>numerator</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>denominator</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>safe_divide</span><span class=p>(</span><span class=mf>10.0</span><span class=p>,</span><span class=w> </span><span class=mf>2.0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Result: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Error: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>error_result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>safe_divide</span><span class=p>(</span><span class=mf>10.0</span><span class=p>,</span><span class=w> </span><span class=mf>0.0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// If you tried to use error_result without handling the Err case,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// the compiler would stop you.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>error_result</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Result: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Error: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In this example, the caller is forced by the <code>match</code> statement&rsquo;s exhaustiveness rule (the same rule we saw with the <code>Request</code> enum) to handle both <strong>success</strong> <code>(Ok)</code> and <strong>failure</strong> <code>(Err)</code>. You cannot simply &ldquo;forget&rdquo; to check for an error. This makes the code far more robust.</p><p>Now that we understand the basics, let&rsquo;s see how this compares to other languages and how Rust makes it more ergonomic.</p><h4 id=gos-if-err--nil-boilerplate>Go&rsquo;s <code>if err != nil</code> Boilerplate:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>file</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=s>&#34;foo.txt&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>err</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// more error checks...</span><span class=w>
</span></span></span></code></pre></div><h4 id=cjavas-invisible-control-flow>C++/Java&rsquo;s Invisible Control Flow:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// several function calls...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// An exception could be thrown from anywhere, it&#39;s not visible in the types.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>IOException</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Handle error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h4 id=rusts--operator>Rust&rsquo;s <code>?</code> Operator:</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fs</span>::<span class=n>File</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>Read</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>read_username_from_file</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=n>io</span>::<span class=n>Error</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The &#39;?&#39; operator propagates the error automatically. If File::open fails,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// the function immediately returns the Err variant.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>file</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>File</span>::<span class=n>open</span><span class=p>(</span><span class=s>&#34;username.txt&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>username</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The &#39;?&#39; operator does the same for the read operation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>file</span><span class=p>.</span><span class=n>read_to_string</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>username</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// If both operations succeed, return the username wrapped in Ok.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=nb>Ok</span><span class=p>(</span><span class=n>username</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The <code>?</code> operator provides concise error propagation that is still explicit and type-checked, offering the best of both worlds: <strong>less boilerplate</strong> than Go and <strong>more safety and clarity</strong> than C++/Java exceptions.</p><p><a href=https://doc.rust-lang.org/book/ch09-00-error-handling.html>See Chapter 9 (&ldquo;Error Handling&rdquo;) of The Rust Book</a>, as well as <a href=https://doc.rust-lang.org/rust-by-example/error.html>Section 18 (&ldquo;Error handling&rdquo;) of Rust by Example (RBE)</a> for more.</p><h2 id=industry-adoption-from-theory-to-production-code>Industry Adoption: From Theory to Production Code</h2><p>The benefits of Rust are not just theoretical. Some of the world&rsquo;s largest technology companies are adopting it for critical, performance-sensitive systems, often replacing existing C++ codebases.</p><ul><li><p><strong>Google:</strong> Rust is a first-class language for systems programming in the <strong>Android Open Source Project</strong>. In a 2022 blog post, Google stated that since introducing Rust, &ldquo;<em>there have been zero memory safety vulnerabilities discovered</em>&rdquo; in their new Rust code. They also reported that based on internal data, &ldquo;<em>Rust developer productivity and satisfaction is high,</em>&rdquo; with developers being twice as productive as their C++ counterparts after overcoming the initial learning curve. Read more on the <a href=https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html>Google Security Blog</a>.</p></li><li><p><strong>Microsoft:</strong> Recognizing that approximately 70% of their yearly security patches are fixes for memory safety bugs in C and C++ code, Microsoft has made a <strong>strategic bet on Rust</strong>. They are actively rewriting core Windows components, including parts of the kernel, in Rust and have an official <a href=https://learn.microsoft.com/en-us/windows/dev-environment/rust/rust-for-windows>&ldquo;Rust for Windows&rdquo;</a> project to provide seamless interoperability with the Windows API.</p></li><li><p><strong>Amazon Web Services (AWS):</strong> AWS has used Rust to build some of its most critical and performance-sensitive infrastructure. <a href=https://firecracker-microvm.github.io/>Firecracker</a>, the virtualization technology that powers AWS Lambda and Fargate, is written in Rust, leveraging its safety and speed for secure multi-tenant isolation.</p></li><li><p><strong>The Linux Kernel:</strong> Perhaps the most significant endorsement for any systems language, Rust was officially accepted for kernel development in 2022, joining the exclusive ranks of C and assembly. This is a milestone that C++, despite its decades of existence, has never achieved (I believe this is what is referred to as &ldquo;skill issue&rdquo; nowadays). The reasons for C++&rsquo;s exclusion were articulated very CLEARLY by Linus Torvalds in a <a href=https://harmful.cat-v.org/software/c++/linus>now-famous 2004 mailing list post</a>:</p><blockquote><p>In fact, in Linux we did try C++ once already, back in 1992. It sucks. Trust me - writing kernel code in C++ is a BLOODY STUPID IDEA. The fact is, C++ compilers are not trustworthy. They were even worse in 1992, but some fundamental facts haven&rsquo;t changed:
the whole C++ exception handling thing is fundamentally broken. It&rsquo;s especially broken for kernels.
any compiler or language that likes to hide things like memory
allocations behind your back just isn&rsquo;t a good choice for a kernel.
you can write object-oriented code (useful for filesystems etc) in C, without the crap that is C++.</p></blockquote><blockquote><p>In general, I&rsquo;d say that anybody who designs his kernel modules for C++ is either
(a) looking for problems
(b) a C++ bigot that can&rsquo;t see what he is writing is really just C anyway
(c) was given an assignment in CS class to do so.</p></blockquote><blockquote><p>Feel free to make up (d).
Linus</p></blockquote><p>Rust, with its predictable performance, explicit error handling (e.g. via <code>Result</code>), and lack of hidden memory allocations, directly addresses these long-standing concerns. Its successful integration for writing new drivers and subsystems is a powerful testament to its suitability for the most demanding software environments in the world.</p></li></ul><h2 id=who-is-rust-for-identifying-the-ideal-use-cases>Who is Rust For? Identifying the Ideal Use Cases</h2><p>Rust is not a silver bullet, but its unique combination of features makes it an ideal choice for a wide range of applications:</p><ul><li><p><strong>Embedded Systems & OS Development:</strong> Where direct hardware access and a predictable memory footprint are non-negotiable.</p></li><li><p><strong>Web Backends & Network Services:</strong> Where performance, security, and robust concurrency are critical for handling thousands of simultaneous connections.</p></li><li><p><strong>Command-Line Tools:</strong> Where fast startup times and a small binary size are highly valued.</p></li><li><p><strong>WebAssembly (WASM):</strong> Rust is a first-class language for WASM, allowing developers to run safe, high-performance code in the browser.</p></li><li><p><em>Anyone who enjoys this kind of programming</em> :)</p></li></ul><h2 id=conclusion-a-new-baseline-for-systems-programming>Conclusion: A New Baseline for Systems Programming</h2><p>Rust represents a significant evolution in programming language design. It proves that a language does not have to sacrifice safety for performance, or developer experience for low-level control. By providing memory safety, fearless concurrency, and a world-class toolchain, it empowers developers to build software that is faster, more reliable, and more secure. While C++ will remain a cornerstone of the industry for years to come, Rust offers a compelling, modern, and, above all, safer path forward for the next generation of systems software.</p></div></article></main><footer class=site-footer><p>&copy; <span id=currentYear>2025</span> Daniel Dia. All rights reserved.</p><p>Powered by
<a href=https://gohugo.io/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">Hugo</a>,
<a href=https://tailwindcss.com/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">Tailwind CSS</a>,
<a href=https://www.goatcounter.com/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">GoatCounter</a>
&
<a href=https://pages.github.com/ class="text-custom-red-500 hover:underline" target=_blank rel="noopener noreferrer">GitHub Pages</a>.</p></footer><script>document.addEventListener("DOMContentLoaded",()=>{const t=document.querySelectorAll("header nav a.nav-link"),n=window.location.pathname;let e={link:null,length:-1};t.forEach(t=>{t.classList.remove("active","text-custom-red-500","bg-custom-red-200","font-semibold"),t.classList.add("text-custom-gray-700");let s=new URL(t.href).pathname;s.length>1&&s.endsWith("/")&&(s=s.slice(0,-1));let o=n;o.length>1&&o.endsWith("/")&&(o=o.slice(0,-1)),(o===s||s!=="/"&&o.startsWith(s+"/"))&&s.length>e.length&&(e.link=t,e.length=s.length)}),e.link&&(e.link.classList.add("active","text-custom-red-500","bg-custom-red-200","font-semibold"),e.link.classList.remove("text-custom-gray-700"))})</script><script data-goatcounter=https://danieldia.goatcounter.com/count async src=//gc.zgo.at/count.js></script><noscript><img src="https://danieldia.goatcounter.com/count?p=/blog/systems_programmer_case_rust" alt></noscript></body></html>